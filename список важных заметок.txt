1) //Function Expression (Функциональное Выражение).
   //так как тут есть присваивание то нужна точка с запятой

2) call back это по сути функция, которую передают в качестве параметра
Ключевая идея в том, что мы передаём функцию
 и ожидаем, что она вызовется обратно (от англ. «call back» –
 обратный вызов) когда-нибудь позже, если это будет необходимо.

3) Объект, объявленный как константа, может быть изменён
Определение const выдаст ошибку только если мы
присвоим переменной другое значение: user=....

4) При обращении к свойству, которого нет,
 возвращается undefined.
 Это позволяет просто проверить существование свойства:


5) Одно из фундаментальных отличий объектов от примитивов
   заключается в том,
   что объекты хранятся и копируются «по ссылке»
   **но
   Объекты, объявленные как константа, могут быть изменены
   Важным побочным эффектом хранения объектов в качестве
   ссылок является то, что объект, объявленный как const,
    может быть изменён.

6) Современные движки реализуют разные
   продвинутые алгоритмы сборки мусора.

   О многих из них рассказано в прекрасной книге о сборке
   мусора «The Garbage Collection Handbook: The Art of Automatic
   Memory Management» (R. Jones и др.).

7) *
   В JavaScript ключевое слово «this» ведёт себя иначе,
    чем в большинстве других языков программирования.
    Его можно использовать в
   любой функции, даже если это не метод объекта.

   Значение this вычисляется во время выполнения кода, в
    зависимости от контекста.
   Например, здесь одна и та же функция назначена двум разным
    объектам и имеет различное значение «this» в вызовах:
    */
   {
       let user = { name: "John" };
       let admin = { name: "Admin" };

       function sayHi() {
           console.log( this.name );
       }
   // используем одну и ту же функцию в двух объектах
       user.f = sayHi;
       admin.f = sayHi;
   // эти вызовы имеют  разное значение this
   // "this" внутри функции - это объект "перед точкой"
       user.f(); // John  (this == user)
       admin.f(); // Admin  (this == admin)
       admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
   }

8) //когда используешь this
   //лучше это делать в режиме strict
   //т.к. в нём мы получим  undefined
   //а в обычном режиме мы получим глобальное window
   {
       function sayHi() {
           console.log(this);
       }

       sayHi(); // undefined
   }

   //У стрелочных функций нет «this»
   /*
   Если мы ссылаемся на this внутри такой функции,
   то оно берётся из внешней «нормальной» функции.
    */

9) Кстати, мы можем не ставить круглые скобки после new, но
   это плохая практика

10) Опциональная цепочка ?. — это безопасный способ доступа к свойствам
    вложенных объектов, даже если какое-либо из промежуточных свойств
    не существует.

11)     //при проверке методов тоже так можно делать
        //но процедура проверки выглядит так
        //и поэтому нужно быть внимательным
        let userAdmin = {
            admin() {
                console.log("Я админ");
            }
        };
        let userGuest = {};
        userAdmin.admin?.(); // Я админ
        userGuest.admin?.(); // ничего не произойдет (такого метода нет)