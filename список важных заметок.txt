1) //Function Expression (Функциональное Выражение).
   //так как тут есть присваивание то нужна точка с запятой

2) call back это по сути функция, которую передают в качестве параметра
Ключевая идея в том, что мы передаём функцию
 и ожидаем, что она вызовется обратно (от англ. «call back» –
 обратный вызов) когда-нибудь позже, если это будет необходимо.

3) Объект, объявленный как константа, может быть изменён
Определение const выдаст ошибку только если мы
присвоим переменной другое значение: user=....

4) При обращении к свойству, которого нет,
 возвращается undefined.
 Это позволяет просто проверить существование свойства:


5) Одно из фундаментальных отличий объектов от примитивов
   заключается в том,
   что объекты хранятся и копируются «по ссылке»
   **но
   Объекты, объявленные как константа, могут быть изменены
   Важным побочным эффектом хранения объектов в качестве
   ссылок является то, что объект, объявленный как const,
    может быть изменён.

6) Современные движки реализуют разные
   продвинутые алгоритмы сборки мусора.

   О многих из них рассказано в прекрасной книге о сборке
   мусора «The Garbage Collection Handbook: The Art of Automatic
   Memory Management» (R. Jones и др.).

7) *
   В JavaScript ключевое слово «this» ведёт себя иначе,
    чем в большинстве других языков программирования.
    Его можно использовать в
   любой функции, даже если это не метод объекта.

   Значение this вычисляется во время выполнения кода, в
    зависимости от контекста.
   Например, здесь одна и та же функция назначена двум разным
    объектам и имеет различное значение «this» в вызовах:
    */
   {
       let user = { name: "John" };
       let admin = { name: "Admin" };

       function sayHi() {
           console.log( this.name );
       }
   // используем одну и ту же функцию в двух объектах
       user.f = sayHi;
       admin.f = sayHi;
   // эти вызовы имеют  разное значение this
   // "this" внутри функции - это объект "перед точкой"
       user.f(); // John  (this == user)
       admin.f(); // Admin  (this == admin)
       admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
   }

8) //когда используешь this
   //лучше это делать в режиме strict
   //т.к. в нём мы получим  undefined
   //а в обычном режиме мы получим глобальное window
   {
       function sayHi() {
           console.log(this);
       }

       sayHi(); // undefined
   }

   //У стрелочных функций нет «this»
   /*
   Если мы ссылаемся на this внутри такой функции,
   то оно берётся из внешней «нормальной» функции.
    */

9) Кстати, мы можем не ставить круглые скобки после new, но
   это плохая практика

10) Опциональная цепочка ?. — это безопасный способ доступа к свойствам
    вложенных объектов, даже если какое-либо из промежуточных свойств
    не существует.

11)     //при проверке методов тоже так можно делать
        //но процедура проверки выглядит так
        //и поэтому нужно быть внимательным
        let userAdmin = {
            admin() {
                console.log("Я админ");
            }
        };
        let userGuest = {};
        userAdmin.admin?.(); // Я админ
        userGuest.admin?.(); // ничего не произойдет (такого метода нет)

12) По спецификации, в качестве ключей для свойств
    объекта могут использоваться только строки или символы.

13) Символы позволяют создавать «скрытые» свойства объектов,
    к которым нельзя нечаянно
    обратиться и перезаписать их из других частей программы.
        Думаю можно в своих либах где-то использовать

14) null/undefined не имеют методов

    Особенные примитивы null и undefined являются исключениями.
    У них нет соответствующих «объектов-обёрток», и они не
    имеют никаких методов. В некотором смысле, они «самые
     примитивные».

    Попытка доступа к свойствам такого значения возвратит
    ошибку:

15) Два нуля
    Другим забавным следствием внутреннего представления чисел является
     наличие двух нулей: 0 и -0.

    Все потому, что знак представлен отдельным битом, так что, любое
     число может быть положительным и отрицательным, включая нуль.
В большинстве случаев это поведение незаметно, так как
операторы в JavaScript воспринимают их одинаковыми.

16) Почему 6.35.toFixed(1) == 6.3?
Во внутреннем двоичном представлении 6.35
alert( 6.35.toFixed(20) ); // 6.34999999999999964473
alert( 1.35.toFixed(20) ); // 1.35000000000000008882

Тут потеря точности приводит к увеличению числа,
 поэтому округление произойдёт в большую сторону.

Каким образом можно исправить
ошибку в округлении числа 6.35?
alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
alert( Math.round(6.35 * 10) / 10 ); // 6.35 -> 63.5 -> 64(rounded) -> 6.4


17) Внутренний формат для строк —
всегда UTF-16, вне зависимости от кодировки страницы.

18) Строки неизменяемы

19) Трюк с побитовым НЕ
    Существует старый трюк с использованием побитового оператора НЕ — ~. Он преобразует
    число в 32-разрядное целое со знаком (signed 32-bit integer).
    Дробная часть, в случае, если она присутствует, отбрасывается. Затем все
    биты числа инвертируются.

    На практике это означает простую вещь: для 32-разрядных
    целых чисел значение ~n равно -(n+1).

    const a = 5;     // 00000000000000000000000000000101
    const b = -3;    // 11111111111111111111111111111101

    console.log(~a); // 11111111111111111111111111111010
    // expected output: -6

    console.log(~b); // 00000000000000000000000000000010
    // expected output: 2

20)
Свойство length автоматически
обновляется при изменении массива. Если быть
точными, это не количество элементов массива,
а наибольший цифровой индекс плюс один.
Например, единственный элемент, имеющий большой индекс,
даёт большую длину:
let fruits = [];
fruits[123] = "Яблоко";
alert( fruits.length ); // 124

21)
Ещё один интересный факт о свойстве
length – его можно перезаписать.
let arr = [1, 2, 3, 4, 5];
arr.length = 2; // укорачиваем до двух элементов
alert( arr ); // [1, 2]
arr.length = 5; // возвращаем length как было
alert( arr[3] ); // undefined: значения не восстановились

22)
В JavaScript, в отличие от некоторых других языков
программирования,
массивы не следует сравнивать при помощи оператора ==.

23)
    let arrayLike = {
        0: "что-то",
        1: "ещё",
        2: 3,
            //если не добавить это свойство то
        //объект просто вствится в конец
        //если добавить то каждое свойство
        //будет добавлено как отдельный элемент
        [Symbol.isConcatSpreadable]: true,
        length: 3 //также важно указать правильную длину
        //а то не зарабоает нормально
    };

    console.log( arr.concat(arrayLike) ); // 1,2,что-то,ещё

24) typeof всё равно что перед ним будет, т.к.
        массив это объект, для различия,
        есть специальный метод Array.isArray()

    console.log(typeof arr)
    console.log(typeof user)
    console.log(Array.isArray(arr));
    console.log(Array.isArray(user));

25)THIS arg - если понадобится то можно будет почиать о нём
тут
https://learn.javascript.ru/array-methods#bolshinstvo-metodov-podderzhivayut-thisarg

26)
/*
map[key] это не совсем правильный
 способ использования Map
Хотя map[key] также работает, например, мы можем
установить map[key] = 2, в этом случае map рассматривался
бы как обычный JavaScript объект, таким
образом это ведёт ко всем соответствующим
 ограничениям (только строки/символьные ключи
  и так далее).

Поэтому нам следует использовать методы map: set,
 get и так далее.

map преобразует все ключи Object, в одну и ту же
строку "[object Object]".
 */

 27) при итерации по map
 Используется порядок вставки
 В отличие от обычных объектов Object, в Map
 перебор происходит в том же порядке, в каком
 происходило добавление элементов.

28) при работе с датой


Никакого getYear(). Только getFullYear()

Многие интерпретаторы JavaScript реализуют
нестандартный и устаревший метод getYear(),
который порой возвращает год в виде двух
цифр. Пожалуйста, обходите его стороной.
Если нужно значение года, используйте getFullYear().

29)
Будьте осторожны с микробенчмарками

Современные интерпретаторы JavaScript выполняют
множество оптимизаций. Они могут повлиять на
результаты «искусственных тестов» по сравнению
с «нормальным использованием», особенно если мы
тестируем что-то очень маленькое, например, работу
оператора или встроенной функции. Поэтому если
хотите серьёзно понять производительность, пожалуйста,
изучите, как работают интерпретаторы JavaScript.
И тогда вам, вероятно, уже не понадобятся микробенчмарки.
Отличный набор статей о V8 можно найти на https://mrale.ph.

30)
JSON не поддерживает комментарии.
Добавление комментария в JSON делает его недействительным.
JSON is data-only. If you include a comment, then it must be data too.
You could have a designated data element called "_comment" (or something) that should be ignored by apps that use the JSON data.
https://stackoverflow.com/questions/244777/can-comments-be-used-in-json



