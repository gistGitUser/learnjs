1) //Function Expression (Функциональное Выражение).
   //так как тут есть присваивание то нужна точка с запятой

2) call back это по сути функция, которую передают в качестве параметра
Ключевая идея в том, что мы передаём функцию
 и ожидаем, что она вызовется обратно (от англ. «call back» –
 обратный вызов) когда-нибудь позже, если это будет необходимо.

3) Объект, объявленный как константа, может быть изменён
Определение const выдаст ошибку только если мы
присвоим переменной другое значение: user=....

4) При обращении к свойству, которого нет,
 возвращается undefined.
 Это позволяет просто проверить существование свойства:


5) Одно из фундаментальных отличий объектов от примитивов
   заключается в том,
   что объекты хранятся и копируются «по ссылке»
   **но
   Объекты, объявленные как константа, могут быть изменены
   Важным побочным эффектом хранения объектов в качестве
   ссылок является то, что объект, объявленный как const,
    может быть изменён.

6) Современные движки реализуют разные
   продвинутые алгоритмы сборки мусора.

   О многих из них рассказано в прекрасной книге о сборке
   мусора «The Garbage Collection Handbook: The Art of Automatic
   Memory Management» (R. Jones и др.).

7) *
   В JavaScript ключевое слово «this» ведёт себя иначе,
    чем в большинстве других языков программирования.
    Его можно использовать в
   любой функции, даже если это не метод объекта.

   Значение this вычисляется во время выполнения кода, в
    зависимости от контекста.
   Например, здесь одна и та же функция назначена двум разным
    объектам и имеет различное значение «this» в вызовах:
    */
   {
       let user = { name: "John" };
       let admin = { name: "Admin" };

       function sayHi() {
           console.log( this.name );
       }
   // используем одну и ту же функцию в двух объектах
       user.f = sayHi;
       admin.f = sayHi;
   // эти вызовы имеют  разное значение this
   // "this" внутри функции - это объект "перед точкой"
       user.f(); // John  (this == user)
       admin.f(); // Admin  (this == admin)
       admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
   }

8) //когда используешь this
   //лучше это делать в режиме strict
   //т.к. в нём мы получим  undefined
   //а в обычном режиме мы получим глобальное window
   {
       function sayHi() {
           console.log(this);
       }

       sayHi(); // undefined
   }

   //У стрелочных функций нет «this»
   /*
   Если мы ссылаемся на this внутри такой функции,
   то оно берётся из внешней «нормальной» функции.
    */

9) Кстати, мы можем не ставить круглые скобки после new, но
   это плохая практика

10) Опциональная цепочка ?. — это безопасный способ доступа к свойствам
    вложенных объектов, даже если какое-либо из промежуточных свойств
    не существует.

11)     //при проверке методов тоже так можно делать
        //но процедура проверки выглядит так
        //и поэтому нужно быть внимательным
        let userAdmin = {
            admin() {
                console.log("Я админ");
            }
        };
        let userGuest = {};
        userAdmin.admin?.(); // Я админ
        userGuest.admin?.(); // ничего не произойдет (такого метода нет)

12) По спецификации, в качестве ключей для свойств
    объекта могут использоваться только строки или символы.

13) Символы позволяют создавать «скрытые» свойства объектов,
    к которым нельзя нечаянно
    обратиться и перезаписать их из других частей программы.
        Думаю можно в своих либах где-то использовать

14) null/undefined не имеют методов

    Особенные примитивы null и undefined являются исключениями.
    У них нет соответствующих «объектов-обёрток», и они не
    имеют никаких методов. В некотором смысле, они «самые
     примитивные».

    Попытка доступа к свойствам такого значения возвратит
    ошибку:

15) Два нуля
    Другим забавным следствием внутреннего представления чисел является
     наличие двух нулей: 0 и -0.

    Все потому, что знак представлен отдельным битом, так что, любое
     число может быть положительным и отрицательным, включая нуль.
В большинстве случаев это поведение незаметно, так как
операторы в JavaScript воспринимают их одинаковыми.

16) Почему 6.35.toFixed(1) == 6.3?
Во внутреннем двоичном представлении 6.35
alert( 6.35.toFixed(20) ); // 6.34999999999999964473
alert( 1.35.toFixed(20) ); // 1.35000000000000008882

Тут потеря точности приводит к увеличению числа,
 поэтому округление произойдёт в большую сторону.

Каким образом можно исправить
ошибку в округлении числа 6.35?
alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
alert( Math.round(6.35 * 10) / 10 ); // 6.35 -> 63.5 -> 64(rounded) -> 6.4


17) Внутренний формат для строк —
всегда UTF-16, вне зависимости от кодировки страницы.

18) Строки неизменяемы

19) Трюк с побитовым НЕ
    Существует старый трюк с использованием побитового оператора НЕ — ~. Он преобразует
    число в 32-разрядное целое со знаком (signed 32-bit integer).
    Дробная часть, в случае, если она присутствует, отбрасывается. Затем все
    биты числа инвертируются.

    На практике это означает простую вещь: для 32-разрядных
    целых чисел значение ~n равно -(n+1).

    const a = 5;     // 00000000000000000000000000000101
    const b = -3;    // 11111111111111111111111111111101

    console.log(~a); // 11111111111111111111111111111010
    // expected output: -6

    console.log(~b); // 00000000000000000000000000000010
    // expected output: 2
