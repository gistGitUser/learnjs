"use strict"

/*

Основной концепцией управления памятью в JavaScript
является принцип достижимости.

Если упростить, то «достижимые» значения – это те, 
которые доступны или используются. Они гарантированно
находятся в памяти.

*/

/*



Существует базовое множество достижимых значений,
которые не могут быть удалены.

Например:
        Выполняемая в данный момент функция, её
        локальные переменные и параметры.
        Другие функции в текущей цепочке вложенных вызовов, их
         локальные переменные и параметры.
        Глобальные переменные.
        (некоторые другие внутренние значения)

    Эти значения мы будем называть корнями.

    Любое другое значение считается достижимым, если оно доступно из
     корня по ссылке или по цепочке ссылок.

    Например, если в глобальной переменной есть объект, и он имеет
    свойство, в котором хранится ссылка на другой объект, то
    этот объект считается достижимым. И те, на которые он ссылается,
    тоже достижимы. Далее вы познакомитесь с подробными примерами
    на эту тему.

В движке JavaScript есть фоновый процесс, который называется
сборщиком мусора.
Он отслеживает все объекты и удаляет те, которые стали недоступными.

 */

//ex 1
{
    let user = {
        name: "John"
    };
    console.log(user);
    user = null;
    //тут объект становится недостижимым и
    //будет убран сборщиком мусора
}

//ex 2
{
    let user = {
        name: "John"
    };
    console.log(user);
    user = null;
    let admin = user;
    //тут память не очистится, т.к. на объект еще есть ссылки
}


//ex3
{

    /*
        В данном примере мы получаем объект внутри которого
        два объекта имеют ссылки друг на друга

        т.е. family ссылается на father и mother
        а внутри них объекты man и woman
         ссылаются друг на друга

     */
    function marry(man, woman){
        woman.husband = man;
        man.wife = woman;

        return {
            father: man,
            mother: woman,
        }
    }

    let family = marry({
        name: "John",
    }, {
        name:"Ann",
    })

    console.log(family);

    /*
    если мы сделаем так, то сборщик мусора удалит
    объект father и соответственно, т.к. на него не
    останентся ссылок
     */
    delete family.father;
    delete family.mother.husband;

    /*
    если сделать так, то будет очищен весь объект
    даже не смотря на то, что внутри объекты будет связаны между
    собой, сборщик мусора все равно удалит их, т.к. корневой элемент
    больше не имеет на них ссылок
     */
    family = null;

}

/*
Внутренние алгоритмы

Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

    Сборщик мусора «помечает» (запоминает) все корневые объекты.
    Затем он идёт по ним и «помечает» все ссылки из них.
    Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
    …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
    Все непомеченные объекты удаляются.

    тут есть картинки
    https://learn.javascript.ru/garbage-collection#vnutrennie-algoritmy

    Оптимизации:

    Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
    Инкрементальная сборка (Incremental collection) – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнения скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
    Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.


 */
























































