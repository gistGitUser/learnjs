"use strict"


/*
результатом obj1 + obj2 (или другой
 математической операции) не может быть другой объект!
 */

/*

    Не существует преобразования к логическому значению.
    В логическом контексте все объекты являются true
    , всё просто. Существует лишь их числовое и строковое
     преобразование.
    Числовое преобразование происходит, когда мы вычитаем
     объекты или применяем математические функции.
     Например, объекты Date (которые будут рассмотрены в
      главе Дата и время) могут быть вычтены, и результатом
       date1 - date2 будет разница во времени между
       двумя датами. Что касается преобразований к строке
        – оно обычно происходит, когда мы выводим на
         экран объект при помощи alert(obj) и в подобных
          контекстах.

    Для преобразования объекта к строке, когда мы
     выполняем операцию
    над объектом, которая ожидает строку, например


    Например, бинарный плюс + может работать как со
    строками (объединяя их в одну), так и с числами
    (складывая их). Поэтому, если бинарный плюс
    получает объект в качестве аргумента,
    он использует хинт "default" для его преобразования.

    Все встроенные объекты, за исключением
    одного (объект Date, который мы рассмотрим
    позже), реализуют "default" преобразование
     тем же способом, что и "number".
     И нам следует поступать так же.


Чтобы выполнить преобразование, JavaScript пытается найти
 и вызвать три следующих метода объекта:

    Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным
    ключом Symbol.toPrimitive (системный символ), если такой
     метод существует,

    Иначе, если хинт равен "string"
        попробовать вызвать obj.toString() или obj.valueOf(),
         смотря какой из них существует.
    Иначе, если хинт равен "number" или "default"
        попробовать вызвать obj.valueOf() или obj.toString(),
        смотря какой из них существует.



 */
{
    let user = {
        name: "John",
        money: 1000,

        [Symbol.toPrimitive](hint) {
            console.log(`hint: ${hint}`);
            return hint === "string" ? `{name: "${this.name}"}`
                : this.money;
        }
    };

// демонстрация результатов преобразований:
    console.log(user); // hint: string -> {name: "John"}
    console.log(+user); // hint: number -> 1000
    console.log(user + 500); // hint: default -> 1500
}




/*
Методы toString и valueOf берут своё начало с древних
 времён. Это не символы (символов тогда ещё не было),
  а скорее просто «обычные» методы со строковыми именами.
   Они предоставляют альтернативный «старомодный»
   способ реализации преобразования.

Эти методы должны возвращать примитивное значение. Если
toString или valueOf возвращает объект, то он
 игнорируется (так же, как если бы метода не было).

По умолчанию обычный объект имеет следующие
методы toString и valueOf:

    Метод toString возвращает строку "[object Object]".
    Метод valueOf возвращает сам объект.


 */

{
    let user = {
        name: "John",
        money: 1000,

        // для хинта равного "string"
        toString() {
            return `{name: "${this.name}"}`;
        },

        // для хинта равного "number" или "default"
        valueOf() {
            return this.money;
        }

    };

    console.log(user); // hint: string -> {name: "John"}
    console.log(+user); // hint: number -> 1000
    console.log(user + 500); // hint: default -> 1500


    let user2 = {
        name: "John",
        money: 1000,
    }

    /* result
    [object Object]2
    [object Object]2
     */
    console.log(user2+2);
    console.log(user2+"2");
    console.log(user2+"2");
    //c умножением строки на строку будет NaN
}
/*
но если например сделать так
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
 */


/*
Важная вещь, которую следует знать обо всех
методах преобразования примитивов, заключается в
 том, что они не обязательно возвращают подсказанный
  хинтом примитив.

Нет никакого контроля над тем, вернёт ли
 toString именно строку, или чтобы метод
  Symbol.toPrimitive возращал именно число для
  хинта "number".

Единственное обязательное условие: эти методы
 должны возвращать примитив, а не объект.
 */

/*
По историческим причинам, если toString или
 valueOf вернёт объект, то ошибки не
 будет, но такое значение будет проигнорировано
  (как если бы метода вообще не существовало).
  Это всё потому, что в древние времена в
   JavaScript не было хорошей концепции «ошибки».

А вот Symbol.toPrimitive уже «четче», этот метод
 обязан возвращать примитив, иначе будет ошибка.

 */

/*
Существует всего 3 типа (хинта) для этого:

    "string" (для alert и других операций,
     которым нужна строка)
    "number" (для математических операций)
    "default" (для некоторых других операторов,
     обычно объекты реализуют его как "number")

 */




























