"use strict"

/*
Map

new Map() – создаёт коллекцию.
map.set(key, value) – записывает по ключу key
                      значение value.
map.get(key) – возвращает значение по
               ключу или undefined, если ключ
               key отсутствует.
map.has(key) – возвращает true, если ключ key
               присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент (пару «ключ/значение»)
                  по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.

 */
{
    let map = new Map();

    map.set("1", "str1");    // строка в качестве ключа
    map.set(1, "num1");      // цифра как ключ
    map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
    console.log(map.get(1)); // "num1"
    console.log(map.get("1")); // "str1"

    console.log(map.size); // 3
}

/*
map[key] это не совсем правильный
 способ использования Map
Хотя map[key] также работает, например, мы можем
установить map[key] = 2, в этом случае map рассматривался
бы как обычный JavaScript объект, таким
образом это ведёт ко всем соответствующим
 ограничениям (только строки/символьные ключи
  и так далее).

Поэтому нам следует использовать методы map: set,
 get и так далее.
 */

{
    let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
    let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
    visitsCountMap.set(john, 123);

    console.log(visitsCountMap.get(john)); // 123

    /*
    let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[ben] = 234; // пробуем использовать объект ben в качестве ключа
visitsCountObj[john] = 123; // пробуйем использовать объект john в качестве ключа, при этом объект ben будет замещён

// Вот что там было записано!
alert( visitsCountObj["[object Object]"] ); // 123

Так как visitsCountObj является объектом, он преобразует
все ключи Object, такие как john и ben, в одну и ту же
строку "[object Object]". Это определенно не то, чего мы хотим.

     */


}

/*
Как объект Map сравнивает ключи
Чтобы сравнивать ключи, объект Map
 использует алгоритм SameValueZero. Это почти
 такое же сравнение, что и ===, с той
 лишь разницей, что NaN считается равным NaN. Так
 что NaN также может использоваться в качестве ключа.

Этот алгоритм не может быть заменён или модифицирован.
 */


/*
map поддерживает цепочку вызовов
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");

 */
//перебор map
{
    let recipeMap = new Map([
        ["огурец", 500],
        ["помидор", 350],
        ["лук",    50]
    ]);
console.log("for  cycle in map")
// перебор по ключам (овощи)
    for (let vegetable of recipeMap.keys()) {
        console.log(vegetable); // огурец, помидор, лук
    }

// перебор по значениям (числа)
    for (let amount of recipeMap.values()) {
        console.log(amount); // 500, 350, 50
    }

// перебор по элементам в формате [ключ, значение]
    for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
        console.log(entry); // огурец,500 (и так далее)
    }
}
/*
Используется порядок вставки
В отличие от обычных объектов Object,
в Map перебор происходит в
том же порядке, в каком происходило добавление элементов.
 */

/*
вообще отдельно стоит где-то пометить что
у js очень удобные возможно по преобразованию
объектов в мапы и массивы

Если у нас уже есть обычный объект, и мы хотели бы
создать Map из него, то поможет встроенный метод
Object.entries(obj), который получает объект и
возвращает массив
пар ключ-значение для него, как раз в этом формате.
 */
{
    let obj = {
        name: "John",
        age: 30
    };

    let map = new Map(Object.entries(obj));

    console.log(map.get('name')); // John

}

/*
Object.fromEntries: Object из Map
Мы только что видели, как создать Map
из обычного объекта при помощи Object.entries(obj).

Есть метод Object.fromEntries, который делает
противоположное: получив массив пар вида [ключ,
значение], он создаёт из них объект:
 */

{
    let prices = Object.fromEntries([
        ['banana', 1],
        ['orange', 2],
        ['meat', 4]
    ]);

// prices = { banana: 1, orange: 2, meat: 4 }

    console.log(prices.orange); // 2
}

/*
Object.fromEntries ожидает перебираемый объект в качестве аргумента,
не обязательно массив. А перебор map как раз возвращает
пары ключ/значение, так же, как и map.entries(). Так что в итоге
у нас будет обычный объект с теми же ключами/значениями, что и в map.
 */


/*
Set
Объект Set – это особый вид коллекции: «множество» значений (без ключей),
где каждое значение может появляться только один раз.

Его основные методы это:
new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен
итерируемый объект (обычно это массив), то копирует его значения в новый Set.
set.add(value) – добавляет значение (если оно уже есть, то ничего
не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true, если value было в
множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве,
иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.
 */

{
    console.log("////////////SET//////////////")
    let set = new Set();

    let john = { name: "John" };
    let pete = { name: "Pete" };
    let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
    set.add(john);
    set.add(pete);
    set.add(mary);
    set.add(john);
    set.add(mary);

// set хранит только 3 уникальных значения
    console.log(set.size); // 3

    for (let user of set) {
        console.log((user.name)); // John (потом Pete и Mary)
    }
}


{
    let set = new Set(["апельсин", "яблоко", "банан"]);

    for (let value of set) console.log(value);

// то же самое с forEach:
    set.forEach((value, valueAgain, set) => {
        console.log(value);
    });
}



{
    console.log("|WeakMap и WeakSet|")
    let john = { name: "John" };

    let map = new Map();
    map.set(john, "...");

// объект john сохранён внутри объекта `Map`,
    console.log(map.keys().next())

    john = null; // перезаписываем ссылку на объект

// он доступен через map.keys()
    console.log(map.get(john)) //undefined
    console.log(map.keys().next()) // но так объект всё равно будет доступен


    /*
    WeakMap
    Первое его отличие от Map в том, что
    ключи в WeakMap должны быть объектами, а не примитивными значениями:
     */

    let weakMap = new WeakMap();

    let obj = {};

    weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
//     weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект

    console.log(weakMap);
    obj = null;
    // объект obj удалён из памяти!
    // в целом интересная штука
    //если нужно оптимизировать память наверное

    /*
    Сравните это поведение с поведением обычного Map, пример которого был приведён ранее. Теперь john существует только как ключ в WeakMap и может быть удалён оттуда автоматически.

    WeakMap не поддерживает перебор и методы keys(), values(),
    entries(), так что нет способа взять все ключи или значения из неё.

В WeakMap присутствуют только следующие методы:

weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)
    К чему такие ограничения? Из-за особенностей технической реализации.
    Если объект станет недостижим (как объект john в примере выше), то он
    будет автоматически удалён сборщиком мусора. Но нет информации,
    в какой момент произойдёт эта очистка.

     */

    /*
    Давайте рассмотрим один пример.

Предположим, у нас есть код, который ведёт учёт посещений для
пользователей. Информация хранится в коллекции Map: объект,
представляющий пользователя, является ключом, а количество
визитов – значением. Когда пользователь нас покидает
(его объект удаляется сборщиком мусора), то больше нет смысла
хранить соответствующий счётчик посещений.
Вот пример реализации счётчика посещений с использованием Map:
*/

// 📁 visitsCount.js
    let visitsCountMap = new Map(); // map: пользователь => число визитов

// увеличиваем счётчик
    function countUser(user) {
        let count = visitsCountMap.get(user) || 0;
        visitsCountMap.set(user, count + 1);
    }

// 📁 main.js
    let john2= { name: "John" };

    countUser(john2); //ведём подсчёт посещений

// пользователь покинул нас
    john = null;

    /*
    Нам нужно очищать visitsCountMap при удалении объекта пользователя, иначе
    коллекция будет бесконечно расти. Подобная очистка может быть
    неудобна в реализации при сложной архитектуре приложения.
     */

// 📁 visitsCount.js
    let visitsCountMap2 = new WeakMap(); // map: пользователь => число визитов

// увеличиваем счётчик
    function countUser2(user) {
        let count = visitsCountMap2.get(user) || 0;
        visitsCountMap.set(user, count + 1);
    }


}

//Применение для кеширования
/*
Другая частая сфера применения – это кеширование, когда результат
вызова функции должен где-то запоминаться («кешироваться») для того,
чтобы дальнейшие её вызовы на том
же объекте могли просто брать уже готовый результат, повторно используя его.
 */

{
    // 📁 cache.js
    let cache = new Map();

// вычисляем и запоминаем результат
    function process(obj) {
        if (!cache.has(obj)) {
            let result = /* тут какие-то вычисления результата для объекта */ obj;

            cache.set(obj, result);
        }

        return cache.get(obj);
    }

    let obj = {/* допустим, у нас есть какой-то объект */};

    let result1 = process(obj); // вычислен результат

// ...позже, из другого места в коде...
    let result2 = process(obj); // ранее вычисленный результат взят из кеша

// ...позже, когда объект больше не нужен:
    obj = null;

    console.log(cache.size); // 1 (Упс! Объект всё ещё в кеше, занимает память!)

    /*
    Недостатком является то,
    что необходимо вручную очищать cache от ставших ненужными объектов.
     */

}

{
    // 📁 cache.js
    let cache = new WeakMap();

// вычисляем и запоминаем результат
    function process(obj) {
        if (!cache.has(obj)) {
            let result = /* вычисляем результат для объекта */ obj;

            cache.set(obj, result);
        }

        return cache.get(obj);
    }

// 📁 main.js
    let obj = {/* какой-то объект */};

    let result1 = process(obj);
    let result2 = process(obj);

// ...позже, когда объект больше не нужен:
    obj = null;
}

{
    /*
    Коллекция WeakSet ведёт себя похоже:

Она аналогична Set, но мы можем добавлять в WeakSet только объекты
(не примитивные значения).
Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
Как и Set, она поддерживает add, has и delete, но не size, keys() и
не является перебираемой.
Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве
 дополнительного хранилища. Но не для произвольных данных, а скорее для
 значений типа «да/нет». Присутствие во множестве WeakSet может что-то
 сказать нам об объекте.

Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто
посещал наш сайт:


     */
}






