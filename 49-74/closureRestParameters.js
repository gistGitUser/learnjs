"use strict"

/*
Многие встроенные функции JavaScript поддерживают
произвольное количество аргументов.

почему не назвать variadic function?
т.к. по сути любая функция в js это v. func?
а для указания того что функция может обработать произвольное
число аргументов используют отдельный термин rest params?
 */
{
    function sum(a, b) {
        return a + b;
    }
    //обработает только два параметра
    console.log( sum(1, 2, 3, 4, 5) );

    function sumAll(...args) { // args — имя массива
        let sum = 0;

        for (let arg of args) sum += arg;

        return sum;
    }

    console.log( sumAll(1, 2, 3, 4, 5) ); //15


    function showName(firstName, lastName, ...titles) {
        console.log(( firstName + ' ' + lastName )); // Юлий Цезарь
        // Оставшиеся параметры пойдут в массив
        // titles = ["Консул", "Император"]
        console.log( titles[0] ); // Консул
        console.log(( titles[1] )); // Император
        console.log(( titles.length )); // 2
    }

    showName("Юлий", "Цезарь", "Консул", "Император");

}

/*
Остаточные параметры должны располагаться в конце

Остаточные параметры собирают все остальные аргументы, поэтому
 бессмысленно писать что-либо после них. Это вызовет ошибку:

function f(arg1, ...rest, arg2) { // arg2 после ...rest ?!
  // Ошибка
}

...rest должен всегда быть последним.
 */

//stop
/*
Раньше в языке не было остаточных параметров, и
получить все аргументы функции можно
было только с помощью arguments. Этот способ всё ещё работает,
мы можем найти его в старом коде.

Но у него есть один недостаток. Хотя arguments похож на массив,
и его тоже можно перебирать, это всё же не массив. Он не
поддерживает методы массивов, поэтому мы не можем, например,
вызвать arguments.map(...).

К тому же, arguments всегда содержит все аргументы функции — мы
не можем получить их часть. А остаточные параметры позволяют это
сделать.

Стрелочные функции не имеют "arguments"
 */

//spread operator
{
    let arr1 = [1, -2, 3, 4];
    let arr2 = [8, 3, -8, 1];
    //работает примерно как и в го, по сути просто разворачивает
    //массив
    console.log( Math.max(1,3,...arr1, ...arr2) ); // 8
    /*
    Под капотом оператор расширения использует итераторы,
    чтобы перебирать элементы.
    Так же, как это делает for..of.
     */
}

{
    /*

    Порядок выполнения кода, приведённого выше:
    если бы он был не в локальной области видимости
В глобальном лексическом окружении есть name: "John".
На строке (*) глобальная переменная изменяется, теперь name: "Pete".
Момент, когда выполняется функция sayHi() и берёт переменную name извне. Теперь из глобального лексического окружения, где переменная уже равна "Pete".
     */
    let name = "John";

    function sayHi() {
        console.log("Hi, " + name); //Pete
    }

    name = "Pete";

    sayHi(); // что будет показано: "John" или "Pete"?
}



{
    function makeWorker() {
        let name = "Pete";

        return function() {
            console.log(name);
        };
    }
    let name = "John";
// create a function
    let work = makeWorker();

// call it
    work(); // что будет показано? "Pete" (из
}

/*
Лексическое Окружение
Чтобы понять, что происходит, давайте для начала обсудим,
что такое «переменная» на самом деле.

В JavaScript у каждой выполняемой функции, блока кода
и скрипта есть связанный с ними внутренний
(скрытый) объект, называемый лексическим окружением
LexicalEnvironment.

Объект лексического окружения состоит из двух частей:

Environment Record – объект, в котором как свойства
 хранятся все локальные
переменные (а также некоторая другая информация,
такая как значение this).

Ссылка на внешнее лексическое окружение – то есть то,
 которое соответствует коду снаружи (снаружи от текущих фигурных
 скобок).

"Переменная" – это просто свойство специального внутреннего объекта
: Environment Record. «Получить или изменить переменную»,
означает, «получить или изменить свойство этого объекта».

Итого:

Переменная – это свойство специального внутреннего объекта,
связанного с текущим выполняющимся блоком/функцией/скриптом.

Работа с переменными – это на самом деле работа со свойствами
 этого объекта.


 */

//Function Declaration
//В отличие от переменных, объявленных с помощью let,
//они полностью инициализируются не тогда, когда
//выполнение доходит до них,
//а раньше, когда создаётся лексическое окружение.

//Для верхнеуровневых функций это означает момент,
//когда скрипт начинает выполнение.

//Вот почему мы можем вызвать функцию, объявленную через
//Function Declaration, до того, как она определена.

//Внутреннее и внешнее лексическое окружение

/*

У внутреннего лексического окружения есть ссылка outer на внешнее.

Когда код хочет получить доступ к переменной – сначала
происходит поиск во внутреннем лексическом окружении, затем во
внешнем, затем в следующем и так далее, до глобального.

Если переменная не была найдена, это будет ошибкой в
strict mode. Без strict mode, для обратной совместимости,
присваивание несуществующей переменной
создаёт новую глобальную переменную с таким именем.



Один вызов – одно лексическое окружение

Пожалуйста, обратите внимание, что новое лексическое
окружение функции создаётся каждый раз, когда функция
выполняется.
И, если функция вызывается несколько раз, то для
каждого вызова будет своё лексическое окружение
, со своими, специфичными для этого вызова, локальными
 переменными и параметрами.


Лексическое окружение – это специальный внутренний объект

«Лексическое окружение» – это специальный внутренний объект. Мы
не можем получить его в нашем коде и изменять напрямую. Сам
движок JavaScript может оптимизировать его,
уничтожать неиспользуемые переменные для освобождения памяти
и выполнять другие внутренние уловки, но видимое поведение
объекта должно оставаться таким, как было описано.

 */

{
    function sayHiBye(firstName, lastName) {

        // функция-помощник, которую мы используем ниже
        function getFullName() {
            return firstName + " " + lastName;
        }

        console.log( "Hello, " + getFullName() );
        console.log( "Bye, " + getFullName() );
    }

    sayHiBye("J","A")
}

{
    // функция-конструктор возвращает новый объект
    function User(name) {
        // методом объекта становится вложенная функция
        this.sayHi = function() {
            console.log(name);
        };
    }
    let user = new User("John");
    user.sayHi(); // у кода метода "sayHi" есть доступ к внешней переменной "name"
}

{
    function makeCounter() {
        let count = 0;

        return function() {
            return count++; // есть доступ к внешней переменной "count"
        };
    }

    let counter = makeCounter();

    console.log( counter() ); // 0
    console.log( counter() ); // 1
    console.log( counter() ); // 2
}

/*
Вот что происходит в примере с makeCounter шаг за шагом.
Пройдите их, чтобы убедиться, что вы разобрались с
 каждой деталью.

Пожалуйста, обратите внимание на дополнительное свойство [[Environment]], про которое
здесь рассказано. Мы не упоминали о нём раньше для простоты.

    Когда скрипт только начинает выполняться, есть только глобальное
     лексическое окружение:

     Все функции «при рождении» получают скрытое свойство [[Environment]], которое
     ссылается на лексическое окружение места, где они были созданы.

Для нашей новой вложенной функции значением [[Environment]] будет текущее
лексическое окружение makeCounter() (где она была создана):

 */

/*
IIFE

В прошлом в JavaScript не было лексического окружения на уровне блоков кода.

Так что программистам пришлось что-то придумать. И то, что они сделали,
называется «immediately-invoked function expressions»
 (аббревиатура IIFE), что означает функцию, запускаемую сразу после объявления.

 (function() {

  let message = "Hello";

  alert(message); // Hello

})();

 */




















